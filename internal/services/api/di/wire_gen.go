// Code generated by Wire. DO NOT EDIT.

//go:generate go run github.com/google/wire/cmd/wire
//+build !wireinject

package di

import (
	"context"
	"github.com/batazor/shortlink/internal/pkg/logger"
	"github.com/batazor/shortlink/internal/services/api/application"
	"github.com/batazor/shortlink/internal/services/link/infrastructure/rpc/link/v1"
	"github.com/batazor/shortlink/internal/services/metadata/infrastructure/rpc"
	"github.com/batazor/shortlink/pkg/rpc"
	"github.com/google/wire"
	"github.com/opentracing/opentracing-go"
	"google.golang.org/grpc"
)

// Injectors from di.go:

func InitializeAPIService(ctx context.Context, runRPCClient *grpc.ClientConn, runRPCServer *rpc.RPCServer, log logger.Logger, tracer *opentracing.Tracer) (*APIService, func(), error) {
	metadataClient, err := NewMetadataRPCClient(runRPCClient)
	if err != nil {
		return nil, nil, err
	}
	linkServiceClient, err := NewLinkRPCClient(runRPCClient)
	if err != nil {
		return nil, nil, err
	}
	linkCommandServiceClient, err := NewLinkCommandRPCClient(runRPCClient)
	if err != nil {
		return nil, nil, err
	}
	linkQueryServiceClient, err := NewLinkQueryRPCClient(runRPCClient)
	if err != nil {
		return nil, nil, err
	}
	server, err := NewAPIApplication(ctx, log, tracer, runRPCServer, metadataClient, linkServiceClient, linkCommandServiceClient, linkQueryServiceClient)
	if err != nil {
		return nil, nil, err
	}
	apiService, err := NewAPIService(log, server)
	if err != nil {
		return nil, nil, err
	}
	return apiService, func() {
	}, nil
}

// di.go:

type APIService struct {
	Logger logger.Logger

	// applications
	service *api_application.Server
}

// APIService ==========================================================================================================
var APISet = wire.NewSet(

	NewLinkRPCClient,
	NewLinkCommandRPCClient,
	NewLinkQueryRPCClient,
	NewMetadataRPCClient,

	NewAPIApplication,

	NewAPIService,
)

func NewLinkRPCClient(runRPCClient *grpc.ClientConn) (v1.LinkServiceClient, error) {
	LinkServiceClient := v1.NewLinkServiceClient(runRPCClient)
	return LinkServiceClient, nil
}

func NewLinkCommandRPCClient(runRPCClient *grpc.ClientConn) (v1.LinkCommandServiceClient, error) {
	LinkCommandRPCClient := v1.NewLinkCommandServiceClient(runRPCClient)
	return LinkCommandRPCClient, nil
}

func NewLinkQueryRPCClient(runRPCClient *grpc.ClientConn) (v1.LinkQueryServiceClient, error) {
	LinkQueryRPCClient := v1.NewLinkQueryServiceClient(runRPCClient)
	return LinkQueryRPCClient, nil
}

func NewMetadataRPCClient(runRPCClient *grpc.ClientConn) (metadata_rpc.MetadataClient, error) {
	metadataRPCClient := metadata_rpc.NewMetadataClient(runRPCClient)
	return metadataRPCClient, nil
}

func NewAPIApplication(
	ctx context.Context, logger2 logger.Logger,

	tracer *opentracing.Tracer,
	rpcServer *rpc.RPCServer,
	metadataClient metadata_rpc.MetadataClient,
	linkServiceClient v1.LinkServiceClient,
	linkCommandRPCClient v1.LinkCommandServiceClient,
	linkQueryRPCClient v1.LinkQueryServiceClient,
) (*api_application.Server, error) {

	API := api_application.Server{
		MetadataClient:           metadataClient,
		LinkServiceClient:        linkServiceClient,
		LinkCommandServiceClient: linkCommandRPCClient,
		LinkQueryServiceClient:   linkQueryRPCClient,
	}

	apiService, err := API.RunAPIServer(ctx, logger2, tracer, rpcServer)
	if err != nil {
		return nil, err
	}

	return apiService, nil
}

func NewAPIService(
	log logger.Logger,

	service *api_application.Server,
) (*APIService, error) {
	return &APIService{
		Logger: log,

		service: service,
	}, nil
}
